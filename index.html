<!DOCTYPE html>
<html>
<head>
<title>Modulation</title>

<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="base.css">
    <script src="base.js"></script>
    <style>
    [class*='col-'] {
        border: 1px dashed #e1e1e8;
        padding: 10px;
    }
    .info {
      line-height: 1.7;
    }
    code {
      padding: 1px 4px;
      border: 1px solid #ebeaea;
      background-color: #fafafa;
    }

    /* Desktop style overrides */
    @media (min-width: 1200px) {
      #location2FormGroup {
        width: 300px;
      }
    }
    </style>

</head>

<body>
<h1>Why segmentation of services is fundamental for long term maintenance for a software project?</h1>
<hr> 
<h2>Introduction </h2>
<p>The vast majority of users aren’t aware of the scope of their favourite software applications, a lot of them where carefully designed to actually be supported for several years, in order to achieve these objectives without affecting the performance or the integrity of the project the developers have a very fundamental but critical task, they must modulate and simplify most of the functionalities and features of the project.</p>
<h2>Fundamentals </h2>
<p>One of the most basics forms of modulation is OOP or Object Oriented programming, this paradigm stablishes that a program should be made with objects, but what is an object?, the best way to describe it is usually to conceptualize any archetype, in this case a chair, and star asking ourselves what makes a chair what it is, this characteristics can be reduced to variables, meaning we can have very different types of chairs but they will still be chairs, henceforth an object programming wise is no more than a clear definition of an abstraction, is on the programmer to define how complex is this abstraction and how dependant is from another objects but overall the idea is to create objects fundamental enough to save development time in future iterations of a software projects, because isn’t the same creating an object defined as human if our project also has to manage other species, then we will be more comfortable creating a creature object, this concept alone simplifies and accelerates the creation of a software project, mostly due to the fact that an OOP development focuses on the reutilization of functions and overall recycling of code, this allows a more lean code, better documentation and more potential support time for the software project.
    But a software project isn’t just conformed by the elements of the software , but actually to the functionalities this elements belong to, and most important , hoy complex we want to make said functionalities, because if we design a functionality that is too complex it becomes too difficult to maintain and expand, but also if said function is too simple it means it should be part of a bigger function, so is the developers task to organize the functionalities of a project in the most integral and sustainable way possible, saving themselves several hours of debugging, maintaining and expanding a badly coded project, instead most developer aim to create a project conformed of simple functionalities that allow very fluid workplace leaving more room to potential features and more constant updates.
    Last we have the task to decide where we put said functionalities and that depends in a lot of situational factors but also on very basic understanding of the purpose of the project, if one function fails the whole program must fail ? do we really need to show the index of a we service even if there is no stock of our products? Will the user really need or use the whole potential of a program every single time? These constraints define the nature of our organization, some projects cant run with just the basics functionalities but other must be constantly on complete operational capabilities, taking all of these concepts in mind que can resume this whole idea to a simple keyword and that would be importance, because is always the task of the developers to define which functionalities are more critical than others, as well as which functions need more processing power, storage or memory, with this kind of dilemmas sorted out we can actually deploy a reliable solution that works in favour of simplicity, flexibility and reliability.
    With all of these ideas in mind que can actually start to notice a very simple patterns which can be simplified in a single word, modularity, turning the mostly of the project into modules in every stage of development causes an effect similar to a LEGO toy, which means that a developer can make and unmake almost any part of the software, also a developer could potentially add more characteristics to a project based on previously stablished frameworks. This idea is present in all layers of a software project and is the key to a successful software implementation.
    </p>
<h2>Benefits</h2>
<p>We can actually state the benefits of modular designs in software projects besides the previously mentioned, first and foremost, a well-structured software project is a solid asset capable to sustain the testo of time and even adapt with it, if we can constantly adapt our Proyecto to be on par with other competitors we can keep an important position on a specific market, also, a good modularity come with a good documentation which allows the company responsible of the project to constantly add more employees to the workforce without damaging the stabilised workflow, lastly we can argue that a well structured project is a demonstration of a well structured workspace an good management, because is a fact that a modern project is usually more notable for is long term support in contrast with its launch.</p>

<h2>Conclusion</h2>
<p>Modularity is a very basic concept that every developer should know but the actual implementation of a good modularity is a challenge that defines the longevity an usability of a software project, in the context of the real word developers must face the fact that a Proyecto usually is a long term compromise, everything they do plan before the actual final implementation could potentially improve the quality of the product in a certain future.</p>
<hr>
<h1>References</h1>
<a href="https://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming)">Abstraction principle</a>
<br>
<a href="https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep">Introduction to Object Oriented Programming Concepts (OOP) and More</a>
<br>
<a href="https://dev.to/tamerlang/separation-of-concerns-the-simple-way-4jp2">Separation of concerns</a>
</body>
</html> 